# Epoll

## IO多路复用

多路是指多个业务方（句柄）并发下来的IO；复用是指复用这一个后台处理程序。

业务方要创建多个`fd`，那么你就需要负责这些`fd`的处理，并且最好还要并发起来，让每一个`fd`通道有独占的错觉。

要求什么呢？快！快！快！这就是最核心的要求。

那我一个IO请求（比如`write`）对应一个线程来处理，这样所有的IO不都并发了吗？是可以，但是有瓶颈，线程数一旦多了，性能是反倒会差的。

> Note：这里不再对比多线程和IO多路复用实现高并发之间的区别，读者可以自行了解。

## 最朴实的实现方式？

我不用任何其他系统调用，能否实现IO多路复用？

可以的。那么写个`for`循环，每次都尝试IO一下，读/写到了就处理，读/写不到就`sleep`下。这样我们不就实现了1对多的IO多路复用嘛。

```C
while True:
    for each 句柄数组 {
        read/write(fd, /* 参数 */)
    }
    sleep(1s)
```

>Note：有个问题，上面的程序可能会被卡死在第三行，使得整个系统不得运行，为什么？
>
>默认情况下，我们没有加任何参数`create`出的句柄是阻塞类型的。我们读数据的时候，如果数据还没准备好，是会需要等待的，当我们写数据的时候，如果还没准备好，默认也会卡住等待。所以，在上面伪代码第三行是可能被直接卡死，而导致整个线程都得到不到运行。
>
>那这个问题怎么解决？只需要把fd都设置成非阻塞模式。
>

以上就是最朴实的IO多路复用的实现了。但是好像在生产环境没见过这种IO多路复用的实现？为什么？

因为还不够高级。`for`循环每次要定期`sleep 1s`，这个会导致吞吐能力极差，因为很可能在刚好要`sleep`的时候，所有的`fd`都准备好IO数据，而这个时候却要硬生生的等待1s，可想而知...

那`for`循环里面就不`sleep`嘛，这样不就能及时处理了吗？

及时是及时了，但是不加`sleep`，那在没有`fd`需要处理的时候，估计CPU都要跑到100% 了。这个也是无法接受的。

纠结了，那`sleep`吞吐不行，不`sleep`浪费CPU，怎么办？

这种情况用户态很难有所作为，只能求助内核来提供机制协助来。因为内核才能及时的管理这些通知和调度。

## 这事Linux内核必须要给个说法？

我们再梳理下IO多路复用的需求和原理：IO多路复用就是1个线程处理多个fd的模式。

我们的要求是：这个“1“就要尽可能的快，避免一切无效工作，**要把所有的时间都用在处理句柄的IO上，不能有任何空转，sleep的时间浪费。**

Linux内核有没有一种工具，我们把一箩筐的`fd`放到里面，只要有一个`fd`能够读写数据，后台`loop`线程就要立马唤醒，全部马力跑起来。其他时间要把CPU让出去。

有，这种需求只能内核提供机制满足你，毕竟IO的处理都是内核之中，数据好没好内核最清楚。

内核提供了3种工具`select, poll, epoll`。为什么有3种？历史不断改进，`矬 -> 较矬 -> 卧槽、高效`的演变而已。

而这三种方式以`epoll`池的效率最高。为什么效率最高？

其实很简单，这里不详说，其实无非就是`epoll`做的无用功最少，`select`和`poll`或多或少都要多余的拷贝，盲猜（遍历才知道）`fd`，所以效率自然就低了。

举个例子，以`select`和`epoll`来对比举例，池子里管理了1024个句柄，`loop`线程被唤醒的时候，`select`都是蒙的，都不知道这1024个`fd`里谁IO准备好了。这种情况怎么办？只能遍历这1024个`fd`，一个个测试。假如只有一个句柄准备好了，那相当于做了1千多倍的无效功。

`epoll`则不同，从`epoll_wait`醒来的时候就能精确的拿到就绪的`fd`数组，不需要任何测试，拿到的就是要处理的。

## epoll池原理

### epoll涉及的系统调用

```shell
# man epoll
epoll_create # 负责创建一个池子，一个监控和管理句柄fd的池子；
epoll_ctl # 负责管理这个池子里的fd增、删、改；
epoll_wait # 就是负责打盹的，让出CPU调度，但是只要有“事”，立马会从这里唤醒；
```

### epoll高效的原理

Linux下，`epoll`一直被吹爆，作为高并发IO实现的秘密武器。其中原理其实非常朴实：**epoll的实现几乎没有做任何无效功。** 我们从使用的角度切入来一步步分析下：

首先，`epoll`的第一步是创建一个池子。这个使用`epoll_create`来做：

```C
// 函数原型：int epoll_create(int size);
// 这个池子对我们来说是用来装fd的黑盒，我们暂不纠结其中细节，
// 我们拿到了一个epollfd，epollfd能唯一代表这个epoll池。
epollfd = epoll_create(1024);
if (epollfd == -1) {
    perror("epoll_create");
    exit(EXIT_FAILURE);
}
```

